<!doctype html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Factory API â€“ DIO</title>
	<link rel=stylesheet href=../assets/stylesheet/index.css>
	<link rel=icon type=image/png href=../assets/images/favicon-large.png sizes=32x32>
	<link rel=icon type=image/png href=../assets/images/favicon-small.png sizes=16x16>
</head>
<body>
	<a href=../ title=index class=logo>
		<img src=../assets/images/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=../>Index</a>
			<a href=../introduction>Introduction</a>
			<a href=../api>API</a>
			<a href=../misc>Miscellaneous</a>
			<a href=../examples>Examples</a>
			<a href=https://github.com/thysultan/dio.js>GitHub</a>
		</nav>
	</header>
	<article>
		<h1>Factory API</h1>

		<h1 id=element>Element</h1>

<pre><code>
createFactory(
	type: function|string|Element
):  (...args) => h(type, ...args)
</code></pre>

		<h1 id=reconciler>Reconciler</h1>

		<p>The following is intended soley for implementors that are interested in implementing a renderer on top of DIO's reconciler, an identical parallel can be drawn from the relationship that ReactNative&trade; shares with React&trade;.</p>

<pre><code>
createFactory(
	type: {...}
): object
</code></pre>

		<p>
			A reconciler for the DOM is shipped by default, however the <code>createFactory</code> API allows us to also create different host reconcilers that might target different platforms.
		</p>

		<p>
			The creation of a client is assumed when an object argument supplied to <code>createFactory</code> does not satisfy the conditions for an element factory.
		</p>

		<p>
			This object should implement the methods it needs to render to the desired target enviroment.
		</p>

		<p>
			For example if we were creating an reconciler for a mobile platform we might need to implement every method, on the other hand if we were doing the same for a DOM based platform could get away with implemnting the methods we want to change to serve our specific need/heuristics.
		</p>

		<blockquote>
			Within the type comments the following <code>{Element}</code> does not refer to a DOM <code>Element</code> but instead a DIO <code>{Element}</code> instance. The <code>Element</code> instance has all the meta data for the element. The <code>"owner"</code> property on an instance is reserved for referencing the host instance, additionally all <code>{Element}</code> instances have additional contextal meta data like <code>"next"</code>, <code>"prev"</code> and <code>"parent"</code> to reference sibling and parent references. An additional property <code>"cache"</code> exists for the need of storing any meta data you might have.
		</blockquote>

		<h2 id=setDocument>setDocument</h2>

		<p>
			Called when initialiazing a mount container. Use this to setup the native view before a mount.
		</p>

<pre><code>
setDocument: (parent: Element) => void
</code></pre>

		<h2 id=setText>setText</h2>

		<p>
			Called when updating a text nodes value. Use this to update a native text instance value.
		</p>

<pre><code>
setText: (element: Element, value: string) => void
</code></pre>

		<h2 id=setComment>setComment</h2>

		<p>
			Called when updating a comments nodes value. Use this to update a native comment instance value.
		</p>

<pre><code>
setComment: (element: Element, value: string) => void
</code></pre>

		<h2 id=setProps>setProps</h2>

		<p>
			Called when assigning an elements individual properties. Use this to update or initialize properties. This method is called in the mount and additionally in the update phase unless <a href="#shouldUpdateProps">shouldUpdateProps</a> returns false.
		</p>

<pre><code>
setProps: (element: Element, name: string, value: any, xmlns: string?) => void
</code></pre>

		<h2 id=shouldUpdateProps>shouldUpdateProps</h2>

		<p>
			Called before updating an elements properties. Use this to opt out of updating properties, for example when you want to apply a batch of properties manually. The default always returns <code>true</code>, when false is returned, <a href="#setProps">setProps</a> is not called. The props argument passed is only a diff of what has changed.
		</p>

<pre><code>
shouldUpdateProps: (element: Element, props: object, xmlns: string?) => boolean
</code></pre>

		<h2 id=getOwner>getOwner</h2>

		<p>
			Called when retrieving an elements interface via <code>findDOMNode</code>. Use this to return a host node or a proxy that exposes a public interface into the host enviroment.
		</p>

<pre><code>
getOwner: (element: Element) => Node
</code></pre>

		<h2 id=getContext>getContext</h2>

		<p>
			Called when setting up a default root context. Use this to setup the root default context of a render tree.
		</p>

<pre><code>
getContext: (element: Element) => object
</code></pre>

		<h2 id=getDocument>getDocument</h2>

		<p>
			Called when retrieving a default container. Use this to reference a default container when a container is not explicity passed to <a href=top-level.html#render>render</a> or <a href="top-level.html#createPortal">createPortal</a>
		</p>

<pre><code>
getDocument: () => Node
</code></pre>

		<h2 id=getTarget>getTarget</h2>

		<p>
			Called when retrieving a node interface from an event object via <code>findDOMNode(event)</code>.
		</p>

<pre><code>
getTarget: (event: object) => Node
</code></pre>

		<h2 id=getType>getType</h2>

		<p>
			Called when retrieving an elements namespace, before an instance is created. Use this to setup an element namespace based on an elements type/props and parent namespace.
		</p>

<pre><code>
getType: (element: Element, xmlns: string?) => string
</code></pre>

		<h2 id=getProps>getProps</h2>

		<p>
			Called when retrieving an elements props, after an instance has been created but before <a href=#setProps>setProps</a>. This is only called in the mounting phase.
		</p>

<pre><code>
getProps: (element: Element) => object
</code></pre>

		<h2 id=getPortal>getPortal</h2>

		<p>
			Called when retrieving a portal instance. Use this to query or find a portal instance.
		</p>

<pre><code>
getPortal: (element: Element) => Node
</code></pre>

		<h2 id=getQuery>getQuery</h2>

		<p>
			Called when hydrating a container. Use this to find the existing instance.
		</p>

<pre><code>
getQuery: (
	element: Element,
	parent: Element,
	previousSibling: Element,
	nextSibling: Element
) => Node
</code></pre>

		<h2 id=isValidTarget>isValidTarget</h2>

		<p>
			Called when validating a instance object.
		</p>

<pre><code>
isValidTarget: (target: object) => boolean
</code></pre>

		<h2 id=isValidComponent>isValidComponent</h2>

		<p>
			Called when validating a custom component class. This corrosponds to <a href="#createComponent">createComponent</a>. When true, <a href="#createComponent">createComponent</a> is used to create the instance.
		</p>

<pre><code>
isValidComponent: (target: object) => boolean
</code></pre>

		<h2 id=isValidEvent>isValidEvent</h2>

		<p>
			Called when validating an event object. This is used in the context of <code>findDOMNode(event)</code>, not to be confused with event listeners.
		</p>

<pre><code>
isValidEvent: (event: object) => boolean
</code></pre>

		<h2 id=removeChild>removeChild</h2>

		<p>
			Called when removing an instance.
		</p>

<pre><code>
removeChild: (element: Element, parent: Element) => void
</code></pre>

		<h2 id=insertBefore>insertBefore</h2>

		<p>
			Called when inserting an instance.
		</p>

<pre><code>
insertBefore: (element: Element, sibling: Element, parent: Element) => void
</code></pre>

		<h2 id=appendChild>appendChild</h2>

		<p>
			Called when appending an instance.
		</p>

<pre><code>
appendChild: (element: Element, parent: Element) => void
</code></pre>

		<h2 id=createElement>createElement</h2>

		<p>
			Called when creating an element instance.
		</p>

<pre><code>
createElement: (element: Element) => Node
</code></pre>

		<h2 id=createComponent>createComponent</h2>

		<p>
			Called when creating a custom component instance.
		</p>

<pre><code>
createComponent: (element: Element) => Node
</code></pre>

		<h2 id=createText>createText</h2>

		<p>
			Called when creating a text instance.
		</p>

<pre><code>
createText: (element: Element) => Node
</code></pre>

		<h2 id=createEmpty>createEmpty</h2>

		<p>
			Called when creating an empty instance.
		</p>

<pre><code>
createEmpty: (element: Element) => Node
</code></pre>

		<h2 id=createComment>createComment</h2>

		<p>
			Called when creating a comment instance.
		</p>

<pre><code>
createComment: (element: Element) => Node
</code></pre>

		<h2 id=createExport>createExport</h2>

		<p>
			Called before <a href=top-level.html#createFactory>createFactory</a> returns exports. Use this to define the clients public API. By default all exports are returned, this serves as an official method to trim down the public API if you don't intend to expose all the API's exposed by DIO.
		</p>

<pre><code>
createExport: (
	exports: object
) => object
</code></pre>

	</article>
	<script src=../assets/javascript/index.js></script>
</body>
</html>
