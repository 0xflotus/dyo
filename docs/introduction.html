<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>DIO â€“ Introduction</title>
	<link rel=stylesheet href=css/stylesheet.css>
	<link rel=icon type=image/png href=../imgs/favicon-large.png sizes=32x32>
	<link rel=icon type=image/png href=../imgs/favicon-small.png sizes=16x16>
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=imgs/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/thysultan/dio.js>GitHub</a>
		</nav>
	</header>
	<article>
		<h1 id=getting-started>Getting Started</h1>

		<p>
			To follow along with this introduction you can use this <a href=https://jsbin.com/movuti/edit?js,output>Hello World Example</a> as code REPL.
		</p>

<pre><code>
dio.render(
  h('h1', 'Hello, world!'),
  document.getElementById('root')
)</code>
</pre>

		<p>This Hello World example should render a heading with the content "Hello World".</p>

		<h1 id=installation>Installation</h1>

		<p>DIO can be installed through the following CDN's.</p>

		<ol>
			<li><a href=https://unpkg.com/dio.js@latest/dist/dio.min.js>unpkg.com/dio.js@latest/dist/dio.min.js</a></li>
		</ol>

		<p>OR through NPM &mdash;</p>
<pre><code>
npm install dio.js --save
</code></pre>

		<h1 id=elements>Introducing Elements</h1>

		<p>
			Elements are the smallest building blocks of an interface. 
			They allow use to create the building blocks that describe what you see on the screen.
		</p>
<pre><code>
const element = h('h1', 'Hello World');
</code></pre>
		<p>
			Elements are backed by JavaScript objects that describe what and how the that particular element should look and behave.
		</p>
		<p>
			Given what to render at any one point in time, the underlining reconciler takes care of updating/mounting these elements correctly to reflect the current state of the interface.
		</p>
		<p>
			Elements are composed of three distinct parts &mdash; type, props and children. These can be used to assign the desired behaviours and properties that we want our elements to assume.
		</p>
	
<pre><code>
const element = h('h1', {
	class: 'red'
}, 'Hello World')
</code></pre>

		<h1 id=components>Components</h1>

		<p>Components allow use to categorize an interface into (in)dependent, reusable pieces.</p>

		<p>Conceptually, components are like JavaScript functions. They accept arbitrary arguments (called "props") and return elements describing what should appear on the screen.</p>

		<h2>Functions and Classes</h2>

		<p>The first varient of a component is a JavaScript <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions>Function</a> that accepts "props" and returns an element.</p>
<pre><code>
function Welcome (props) {
	return h('h1', 'Hello', props.name)
}
</code></pre>

		<p>The second varient of a component is a <a href=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes>JavaScript Class</a> which implements a "render" method that returns an element.</p>

<pre><code>
class Welcome {
	render() {
		return h('h1', 'Hello', this.props.name)
	}
}
</code></pre>
	
		<p>Components accept "props", "state" &amp; "context" arguments.</p>

		<p>
			For the most part function and class components are equivalent.
		</p>

		<h2>Rendering a Component</h2>

<pre><code>
function Welcome({name}) {
  return h('h1', name)
}

dio.render(
  h(Welcome, {name: 'World'}),
  document.getElementById('root')
)
</code></pre>

		<h1 id=lifecycles>Lifecycles</h1>

		<p>
			Lifecycles allow us to observer the different states that a component unit goes through in the render process.
		</p>

		<h2>Function Lifecycles</h2>

<pre><code>
function Welcome () {
	return h('h1', props.name)
}
Welcome.componentDidMount = () => {}
</code></pre>

		<h2>Class Lifecycles</h2>

<pre><code>
class Welcome {
	componentDidMount() {}
	render({name}) {
		return h('h1', name)
	}
}
</code></pre>

		<p>
			When implementated lifecycles are invoked in certain stages of the components render process.
		</p>

		<hr>

		<table>
			<thead>
				<tr>
					<th>Lifecycle method</th>
					<th>When it gets called</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><code>getInitialState</code></td>
					<td>After instantiating a component</td>
				</tr>
				<tr>
					<td><code>componentWillMount</code></td>
					<td>Before mounting</td>
				</tr>
				<tr>
					<td><code>componentDidMount</code></td>
					<td>After mounting</td>
				</tr>
				<tr>
					<td><code>componentWillReceiveProps</code></td>
					<td>Before new props are received</td>
				</tr>
				<tr>
					<td><code>shouldComponentUpdate</code></td>
					<td>Before the component is updated</td>
				</tr>
				<tr>
					<td><code>componentWillUpdate</code></td>
					<td>Before the component is updated</td>
				</tr>
				<tr>
					<td><code>componentDidUpdate</code></td>
					<td>After the component has updated</td>
				</tr>
				<tr>
					<td><code>componentWillUnmount</code></td>
					<td>Before removed</td>
				</tr>
			</tbody>
		</table>

		<h1 id=events>Events &amp; State</h1>
	
		<p>Events allow us to respond to interactive behaviour.</p>

		<p class=math>V=f(s)</p>

<pre><code>
class Input {
	handleInput({target}) {
		return {value: target.value}
	}
	render() {
		return [
			h('input', {
				type: 'text', 
				oninput: this.handleInput
			}),
			h('h1', this.state.value)
		]
	}
}

dio.render(h(Input), document.getElementById('root'))
</code></pre>

		<h1 id=interoperability>Interoperability</h1>

		<p>
			Outside of the the elements DIO can create we sometimes need a mechanism to interop with the native View, this is where the concept of refs come into play.
		</p>

		<h2>Refs</h2>

		<p>
			Refs allow us to reference the underline native View node that an element creates.
		</p>

<pre><code>
const Welcome = return h('h1', {
	ref: el => console.log(el)
}, 'Welcome')
</code></pre>

		<h2>Portals</h2>

		<p>
			Portals allow us to render some of a components children outside of itself while preserving the colocation relationship between the two.
		</p>

<pre><code>
const portal = document.querySelector('.modal')

dio.render(
	['Hey', h(portal, 'Welcome', 'Back')], 
	document.getElementById('root')
)
</code></pre>

		<p>
			While "Hey" will render in the defined root container, our two text elements
			"Welcome" &amp; "Back" will render within the defined portal.
		</p>


		<h1 id=jsx>Introducing JSX</h1>

		<p>
			JSX is an optional syntax extension that enables you to write HTML tags interspersed with JavaScript.
		</p>

		<p>
			It is not a requirement, but it may be more pleasing to use depending on your preferences.
		</p>

		<p>For example writing <code>h('h1', 'Hello')</code> as <code>&lt;h1>Hello&lt;/h1></code></p>

		<h2>JSX Pragma</h2>

		<p>A pragma <code>/* @jsx h */</code> is a comment that instructs the JSX compiler to use a function.</p>

		<p>For example <code>h</code> as the calling function, in turn transforming <code>&lt;h1>Hello&lt;/h1></code> into <code>h('h1', null, 'Hello')</code></p>

		<p>Most JSX compilers will support pragma comments but they are only scoped to the files they are defined. This might make for a sub-optimal experience depending on your preferences; But it is possible to define a project setup through Babel/Typescript.</p>

		<h2>Setup</h2>

		<p>
			Babel <label></label> 
			<span class=note>
				<a href=http://babeljs.io>Babel</a> is a JavaScript transpiler best known for its ability to turn ES6 (the next version of JavaScript) into code that runs in your browser (or on your server) today.
			</span>
			&mdash;
		</p>

<pre><code>
{
  "plugins": [
  	["transform-react-jsx", { "pragma":"h" }]
  ]
}
</code></pre>

		<p>
			Typescript <label></label> 
			<span class=note>
				<a href=https://www.typescriptlang.org>Typescript</a> is a typed superset of JavaScript that compiles to plain JavaScript.
			</span>
			&mdash;
		</p>

<pre><code>
{
  "compilerOptions": {
    "jsx": "React",
    "jsxFactory": "h"
  }
}
</code></pre>

		<h1>Moving Foward</h1>

		<p>There's still a few pieces we haven't gone into that the <a href=api.html>API</a> documentation will hopefully help shed some light upon.</p>

		<p>At this point you can jump right into creating something with DIO, look at some <a href=examples.html>Examples</a> or learn how DIO works under the hood on <a href=https://github.com/thysultan/dio.js>GitHub</a>.</p>

		<p>If you've made anything with DIO i'd be happy to add it to the small list of examples currently available.</p>
	</article>

	<script src=js/highlight.js></script>
	<script src=js/main.js></script>
</body>
</html>
