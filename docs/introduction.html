<!doctype html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Dyo - A JavaScript library for building user interfaces</title>
	<link rel=stylesheet href=assets/stylesheet/index.css>
	<link rel=icon type=image/png href=assets/images/favicon-large.png sizes=32x32>
	<link rel=icon type=image/png href=assets/images/favicon-small.png sizes=16x16>
	<script defer src=./assets/javascript/index.js></script>
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=assets/images/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./advanced.html>Advanced</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/dyo/dyo>GitHub</a>
		</nav>
	</header>
	<article>
		<h1>Introduction</h1>

		<h1 id=installation>Installation</h1>

		<p>Dyo can be sourced through the following CDN's.</p>

		<ol>
			<li><a href=https://unpkg.com/dyo>unpkg.com/dyo</a></li>
			<li><a href=https://cdn.jsdelivr.net/npm/dyo>cdn.jsdelivr.net/npm/dyo</a></li>
		</ol>

<pre><code>
&lt;script src="unpkg.com/dyo">&lt;/script>
</code></pre>

		<p>OR installed through NPM &mdash;</p>
<pre><code>
npm install dyo --save
</code></pre>

		<h1 id=getting-started>Getting Started</h1>

		<p>The following is the "Hello World" example of Dyo.</p>

<pre><code>
import {render} from 'dyo'

render('Hello, world!', document)
</code></pre>

		<p>This example should render a heading with the content 'Hello World!' into the root of the document.</p>

		<h1 id=introducing-elements>Introducing Elements</h1>

<pre><code>
const element = h('h1', 'Hello World')
</code></pre>
		<p>Elements are represented by JavaScript objects that describe what and how a particular element should look and behave.</p>

		<p>Given what to render at any one point in time, Dyo takes care of mounting and updating these elements to reflect the current state of the interface.</p>

		<p>Elements are composed of three distinct parts &mdash; <strong>type</strong>, <strong>props</strong> and <strong>children</strong>. These can be used to assign desired behaviours and properties for elements to assume.</p>

		<p>In the following we describe a heading element with a class attribute and the text content <em>"Hello World"</em>.</p>

<pre><code>
const element = h('h1', {class: 'red'}, 'Hello World')
</code></pre>

		<h1 id=components>Components</h1>

		<p>Components are independent, reusable building blocks of an interface.</p>

		<p>Conceptually, components are like JavaScript functions. They accept arbitrary arguments and return elements describing the appearance and behavior of the interface.</p>

		<h2>Functions and Classes</h2>

		<p>The first varient of a component is a JavaScript <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions>Function</a>.</p>
<pre><code>
function Welcome (props) {
	return h('h1', 'Hello', props.name)
}
</code></pre>

		<p>The second varient of a component is a <a href=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes>JavaScript Class</a> that implements a render method.</p>

<pre><code>
class Welcome {
	render(props) {
		return h('h1', 'Hello', props.name)
	}
}
</code></pre>

		<p>Components accept <strong>props</strong>, <strong>state</strong> and <strong>context</strong> as arguments.</p>

		<p>Function and class components are equivalent in what can be archived with them.</p>

		<h2>Rendering a Component</h2>

<pre><code>
function Welcome(props) {
	return h('h1', props.name)
}

render(h(Welcome, {name: 'World'}), document)
</code></pre>

		<p>The example demonstrates that like elements we can render components and pass arbitrary arguments <em>"props"</em> to component.</p>

		<h1 id=lifecycles>Lifecycles</h1>

		<p>Lifecycle methods are methods that gets executed during the different phases of a component. When the component gets created, when the component updates, and when the component gets unmounted.</p>

		<p>The following are examples of lifecycle methods on both <strong>function</strong> and <strong>class</strong> components.</p>

		<h2>Function Lifecycle</h2>

<pre><code>
function Welcome (props) {
	return h('h1', props.name)
}

Welcome.componentDidMount = () => {}
</code></pre>

		<h2>Class Lifecycle</h2>

<pre><code>
class Welcome {
	render(props) {
		return h('h1', props.name)
	}
	componentDidMount() {}
}
</code></pre>

		<p>Each lifecycle method is called at a deterministic interval.</p>

		<hr>

		<table>
			<thead>
				<tr>
					<th>Lifecycle method</th>
					<th>When it gets called</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><code>getDerivedState</code></td>
					<td>Before mounting and when updating props</td>
				</tr>
				<tr>
					<td><code>componentDidMount</code></td>
					<td>After the component has mounted</td>
				</tr>
				<tr>
					<td><code>shouldComponentUpdate</code></td>
					<td>Before the component is updated</td>
				</tr>
				<tr>
					<td><code>componentDidUpdate</code></td>
					<td>After the component has updated</td>
				</tr>
				<tr>
					<td><code>componentWillUnmount</code></td>
					<td>Before the component is unmounted</td>
				</tr>
				<tr>
					<td><code>componentDidCatch</code></td>
					<td>When an exception is raised within the component</td>
				</tr>
			</tbody>
		</table>

		<h1 id=events-and-state>Events &amp; State</h1>

		<p>Events form the interactive bridge between the user and interface.</p>

		<p>The following example demonstrates this through a text input element and an <a href=https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/oninput>onInput</a> event that is dispatched when data is exchanged.</p>

<pre><code>
class Input {
	render() {
		return h('form',
			h('h1', this.state.value)
			h('input', {type: 'text', onInput: this.handleEvent})
		)
	}
	handleEvent({target}) {
		return {value: target.value}
	}
}

render(h(Input), document)
</code></pre>

		<p>The example creates a brdige between the value of the <code>&lt;h1></code> element and the value of the <code>&lt;input></code> element whenever an <code>input</code> event is dispatched.</p>

		<h1 id=interoperability>Interoperability</h1>

		<p>The <strong>ref</strong> prop plural: <em>refs</em>; allows authors the ability to retrieve a reference to the host node that a virtual element creates.</p>

		<p>These come in three varients: <strong>function</strong>, <strong>object</strong> and <strong>string</strong> refs.</p>

		<h2>Function Refs</h2>

<pre><code>
class Welcome {
	render(props) {
		return h('h1', {ref: (value) => this.current = value})
	}
	componentDidMount() {
		console.log(this.current)
	}
}
</code></pre>

		<h2>Object Refs</h2>

<pre><code>
class Welcome {
	render(props) {
		return h('h1', {
			ref: this
		}, props.name)
	}
	componentDidMount() {
		console.log(this.current)
	}
}
</code></pre>

		<h2>String Refs</h2>

<pre><code>
class Welcome {
	render(props) {
		return h('h1', {
			ref: 'heading'
		}, props.name)
	}
	componentDidMount() {
		console.log(this.refs.heading)
	}
}
</code></pre>

		<p>All refs are dispatched with the reference element when mounted or updated and with a <code>null</code> reference when unmounted or updated.</p>

		<h1>Portals</h1>

		<p>Portals provide a first-class interface to render children into a container that exists outside the surrounding elements hierarchy of the parent component.</p>

<pre><code>
render(h('h1', {}, 'A', createPortal('B', document.head)), document.body)
</code></pre>

		<p>The following example demonstrates that we can both render the text element <em>"A"</em> into the defined documents body, while also defining that it has a child element <em>"B"</em> that renders into the head of the document.</p>

		<h1 id=introducing-jsx>Introducing JSX</h1>

		<p>JSX is an optional syntax extension that enables you to write HTML tags interspersed with JavaScript.</p>

		<p>It is not a requirement, but it may be more pleasing to use depending on your preferences.</p>

		<p>For example writing <code>h('h1', 'Hello')</code> as an html dialect: <code>&lt;h1>Hello&lt;/h1></code>.</p>

		<h2>JSX Pragma</h2>

		<p>A pragma <code>/* @jsx h */</code> is a comment that instructs the JSX compiler to use a function.</p>

		<p>For example <code>h</code> as the calling function, in turn transforming <code>&lt;h1>Hello&lt;/h1></code> into <code>h('h1', null, 'Hello')</code>.</p>

		<p>Most JSX compilers will support pragma comments but they are only scoped to the files they are defined in. This might make for a sub-optimal experience depending on your preferences; But it is possible to define a project setup through Babel/Typescript.</p>

		<h2>Setup</h2>

		<p>Babel &mdash;</p>

		<blockquote>
			<a href=http://babeljs.io>Babel</a> is a JavaScript transpiler best known for its ability to turn ES6 (the next version of JavaScript) into code that runs in your browser (or on your server) today.
		</blockquote>

<pre><code>
{
	"plugins": [
		["transform-react-jsx", {
			"pragma": "h",
			"pragmaFrag": "Fragment"
		}]
	]
}
</code></pre>

		<p>Typescript &mdash;</p>

		<blockquote>
			<a href=https://www.typescriptlang.org>Typescript</a> is a typed superset of JavaScript that compiles to plain JavaScript.
		</blockquote>

<pre><code>
{
	"compilerOptions": {
		"jsx": "React",
		"jsxFactory": "h"
	}
}
</code></pre>

		<h1>Moving Foward</h1>

		<p>There are details we haven't gone into that hopefully the <a href=./api.html>API</a> and <a href=./advanced.html>Advanced</a> sections can help document.</p>

		<p>At this point you can jump right into creating something with Dyo, look at some <a href=./examples.html>Examples</a> or learn and contribute to Dyo on <a href=https://github.com/dyo/dyo>GitHub</a>.</p>
	</article>
</body>
</html>
