<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>DIO – Introduction</title>
	<link rel=stylesheet href=css/stylesheet.css>
	<link rel=icon type=image/png href=../imgs/favicon-large.png sizes=32x32>
	<link rel=icon type=image/png href=../imgs/favicon-small.png sizes=16x16>
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=imgs/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/thysultan/dio.js>GitHub</a>
		</nav>
	</header>
	<article>
		<h1 id=getting-started>Getting Started</h1>

		<p>
			The easiest way to get started with DIO is to use this <a href=https://jsbin.com/movuti/edit?js,output>Hello World Example</a> and follow along through the code snippets.
		</p>

		<p>The Hello World of DIO:</p>

<pre><code>
dio.render(
  h('h1', 'Hello, world!'),
  document.getElementById('root')
)</code>
</pre>

		<p>This renders a heading saying with the text "Hello World".</p>

		<p>The next few sections will gradually introduce you to the building blocks that make up an application; Elements, Components &amp; Events. Once you master them, you can create simple–to–complex applications.</p>

		<h1 id=installation>Installation</h1>

		<p>DIO can be installed through any one of the following CDN's.</p>

		<ol>
			<li><a href=https://cdnjs.cloudflare.com/ajax/libs/dio/8.0.0/dio.min.js>cdnjs.cloudflare.com/ajax/libs/dio/7.0.3/dio.min.js</a></li>
			<li><a href=https://cdn.jsdelivr.net/npm/dio.js@latest/dio.min.js>cdn.jsdelivr.net/npm/dio.js@latest/dio.min.js</a></li>
			<li><a href=https://unpkg.com/dio.js@latest/dio.min.js>unpkg.com/dio.js@latest/dio.min.js</a></li>
		</ol>

		<p>OR through NPM &mdash;</p>
<pre><code>
`npm install dio.js --save`
</code></pre>

		<h1 id=elements>Introducing Elements</h1>

		<p>Elements are the smallest building blocks of an application.</p>
		<p>An element describes what you want to see on the screen:</p>
<pre><code>
const element = h('h1', 'Hello World');
</code></pre>
		<p>
			Elements are backed by JavaScript objects that describe what and how the that particular element should behave.
		</p>
		<p>
			Knowing what to render at any one point in time DIO's underlining reconciler takes care of updating the native DOM to match the elements you create.
		</p>
		<p>
			Elements are composed of three parts; type <label for="1"></label>,
			<span class=note>
				type represents the type of element that should be rendered.
			</span>
			props <label for="2"></label> and
			<span class=note>
				props represent the properties associated with the element.
			</span>
			children <label for="3"></label>.
			Each part describes a specific aspect of the element.
			<span class=note>
				children represents the children contained within the element.
			</span>
		</p>
	
<pre><code>
const element = h('h1', {
	class: 'red'
}, 'Hello World')
</code></pre>

		<h1 id=components>Components</h1>

		<p>Components let you split an interface into independent, reusable pieces.</p>

		<p>Conceptually, components are like JavaScript functions. They accept arbitrary arguments (called "props") and return elements describing what should appear on the screen.</p>

		<h2>Functions and Classes</h2>

		<p>The first varient of a component is a JavaScript Function.</p>
<pre><code>
function Welcome (props) {
	return h('h1', 'Hello', props.name)
}
</code></pre>
		<p>The second varient of a component is a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">JavaScript Class</a>.</p>

<pre><code>
class Welcome {
	render() {
		return h('h1', 'Hello', this.props.name)
	}
}
</code></pre>

		<p>
			Both of these units accept <code>props</code>, <code>state</code> and <code>`context`</code> as arguments and return elements.
		</p>

		<p>
			Function and Class Components are for the most part equivalent with a few exceptions.
		</p>

		<h2>Rendering a Component</h2>

<pre><code>
function Welcome({name}) {
  return h('h1', name)
}

dio.render(
  h(Welcome, {name: 'World'}),
  document.getElementById('root')
)
</code></pre>

		<h1 id=lifecycles>Lifecycles</h1>

		<p>
			Lifecycles allow us to observer the different states that our component units go through in the render piple.
		</p>

		<h2>Function Lifecycles</h2>

<pre><code>
function Welcome () {
	return h('h1', props.name)
}
Welcome.componentDidMount = () => {}
</code></pre>

		<h2>Class Lifecycles</h2>

<pre><code>
class Welcome {
	componentDidMount() {}
	render({name}) {
		return h('h1', name)
	}
}
</code></pre>

		<p>
			Lifecycles are invoked in certain stages of the components render pipeline.
		</p>

		<hr>

		<table>
			<thead>
				<tr>
					<th>Lifecycle method</th>
					<th>When it gets called</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><code>getInitialState</code></td>
					<td>After instantiating a component</td>
				</tr>
				<tr>
					<td><code>componentWillMount</code></td>
					<td>Before mounting</td>
				</tr>
				<tr>
					<td><code>componentDidMount</code></td>
					<td>After mounting</td>
				</tr>
				<tr>
					<td><code>componentWillUnmount</code></td>
					<td>Before removed</td>
				</tr>
				<tr>
					<td><code>componentWillReceiveProps</code></td>
					<td>Before new props are received</td>
				</tr>
				<tr>
					<td><code>shouldComponentUpdate</code></td>
					<td>Before the component is updated</td>
				</tr>
				<tr>
					<td><code>componentWillUpdate</code></td>
					<td>After <code>shouldComponentUpdate</code></td>
				</tr>
				<tr>
					<td><code>componentDidUpdate</code></td>
					<td>After the component has updated</td>
				</tr>
			</tbody>
		</table>

		<h1 id=events>Events &amp; State</h1>
	
		<p>Events allow us to respond to interactive behaviour.</p>

		<p class=math>V=f(s)</p>

<pre><code>
class Input {
	handleInput({target}) {
		return {value: target.value}
	}
	render() {
		return [
			h('input', {type: 'text', oninput: this.handleInput}),
			h('h1', this.state.value)
		]
	}
}

dio.render(h(Input), document.getElementById('root'))
</code></pre>

		<h1 id=interoperability>Interoperability</h1>

		<p>
			Outside of the the elements DIO can create we sometimes need a mechanisms to interop with the native DOM, this is where the concept of refs come into play.
		</p>

		<h2>Refs</h2>

		<p>
			Refs allow us to reference the underline native DOM node represented the element DIO creates.
		</p>

<pre><code>
const Welcome = return h('h1', {
	ref: el => console.log(el)
}, 'Welcome')
</code></pre>

		<h2>Portals</h2>

		<p>
			Portals allow us to render some of a components children outside of itself while preserving the colocation relationship between the two.
		</p>

<pre><code>
const portal = document.querySelector('.modal')

dio.render(
	['Fox', h(portal, 'Welcome', 'Back')], 
	document.getElementById('root')
)
</code></pre>

		<p>
			While <code>Fox</code> will render in the defined root container, our two text elements
			<code>Welcome</code> &amp; <code>Back</code> will render in our portal.
		</p>


		<h1 id=jsx>Introduction JSX</h1>

		<p>
			JSX is an optional syntax extension that enables you to write HTML tags interspersed with JavaScript.
		</p>

		<p>
			It is not required in DIO, but it may be more pleasing to use depending on your preferences.
		</p>

		<p>For example writing <code>`h('h1', 'Hello')`</code> as <code>`&lt;h1>Hello&lt;/h1>`</code></p>

		<h2>JSX Pragma</h2>

		<p>A pragma <code>/* @jsx h */</code> is a comment that instructs the JSX compiler to use a function for example. <code>`h`</code> as the calling function, in turn transforming <code>`&lt;h1>Hello&lt;/h1>`</code> into <code>h('h1', null, 'Hello')</code></p>

		<p>Most JSX compilers will support pragma comments but they are only scoped to the files they are defined. This might make for sub-optimal experience depending on your preferences; But it is possible to define a project setup through Babel/Typescript.</p>

		<h2>Setup</h2>

		<p>
			Babel <label for=4></label> 
			<span class=note>
				<a href=http://babeljs.io>Babel</a> is a JavaScript transpiler best known for its ability to turn ES6 (the next version of JavaScript) into code that runs in your browser (or on your server) today.
			</span>
			&mdash;
		</p>

<pre><code>
{
  "plugins": [
  	["transform-react-jsx", { "pragma":"h" }]
  ]
}
</code></pre>

		<p>
			Typescript <label for=5></label> 
			<span class=note>
				<a href=https://www.typescriptlang.org>Typescript</a> is a typed superset of JavaScript that compiles to plain JavaScript.
			</span>
			&mdash;
		</p>

<pre><code>
{
  "compilerOptions": {
    "jsx": "React",
    "jsxFactory": "h"
  }
}
</code></pre>

		<h1>Moving Foward</h1>

		<p>There's still a few pieces we haven't gone into that the <a href=api.html>API</a> documentation will help hopefully shed more light upon.</p>

		<p>At this point you can jump right into creating something with DIO, look at some <a href=examples.html>Examples</a> or learn how DIO works under the hood on <a href=https://github.com/thysultan/dio.js>GitHub</a>.</p>

		<p>If you've made anything with DIO i'd be happy to add it to the small list of examples currently available.</p>
	</article>

	<script src=js/highlight.js></script>
	<script src=js/main.js></script>
</body>
</html>
