<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>DIO</title>
	<link rel=stylesheet href=stylesheet.css>
	<link rel="icon" type="image/png" href="favicon-large.png" sizes="32x32">
	<link rel="icon" type="image/png" href="favicon-small.png" sizes="16x16">
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/thysultan/dio.js>Github</a>
		</nav>
	</header>
	<article>
		<h1>API</h1>

		<p>
			DIO's API surface is small to a benefit, <br>with a close resemblance to React <label for=1></label>.
			<span class="note">For example: <code>setState</code>, <code>forceUpdate</code></span>
		</p>

		<h1>Components</h1>

		<p>
			Components can be either a <code>class</code> or a <code>function</code>, and though the class syntax can extend <code>dio.Component</code> DIO accepts plain classes alike.
		</p>

		<h2>Classes</h2>

<pre><code>
class Welcome {
	render() {
		return 'Welcome';
	}
}
</code></pre>

<pre><code>
class Welcome extends dio.Component {
	render() {
		return 'Welcome'
	}
}
</code></pre>

<pre><code>
function Welcome {}
Welcome.prototype = {
	render() {
		return 'Welcome'
	}
}
</code></pre>

		<h2>Functions</h2>
<pre><code>
function Welcome () {
	return 'Welcome'
}
</code></pre>

<pre><code>
function* Welcome () {
	return 'Welcome'
}
</code></pre>

		<h1>Lifecycle</h1>

		<p>
			Both <code>function</code> and <code>class</code> components can make use of lifcycles <label for=2></label>.
			<span class="note">
				With the exception of <code>`getInitialState`</code> that is reserved soley for <code>`class`</code> component which could be used to retrieve the initial state of a class component if required.
			</span>
		</p>

		<p>When required any lifecycle on a <code>`class`</code> based component can call <code>`this.setState`</code> or return a state update object to update the state.</p>

		<h2>Data</h2>

<pre><code>
class Welcome {
	getInitialState() {}
}
</code></pre>

		<p>
			The default return value that <code>`getInitialState`</code> expects is an object representing the initial state of the component; However <code>`getInitialState`</code> also accepts a <code>`Promise`</code> when the data the component requires is network bound <label for=3></label>.
			<span class="note">That is to say you can asynchronous-ly retrieve a components initial state.</span>
		</p>

		<h2>Mounting</h2>

		<p>Mounting happens in a down-top flow in that the lifecycle method of child components will be invoked before the parent.</p>

<pre><code>
class Welcome {
	componentWillMount() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidMount() {}
}
</code></pre>

		<h2>Refs</h2>

		<p>
			Refs are either functions of strings that provide access to the underlining DOM node; While <code>string</code>
			<label for=4></label>
			<span class="note">String refs are only usefull on <code>class</code> based components.</span>
			refs are can be dynamic, <code>function</code>
			refs can also return or call <code>`this.setState`</code> to update the component.</p>

<pre><code>
class Welcome {
	retrieveDOM(el) {
		console.log(el.getBoundingClientRect())
	}
	render() {
		return h('h1', {
			ref: this.retrieveDOM
		}, 'Welcome')
	}
}
</code></pre>

		<h2>Updating</h2>

		<p>Certain Lifecycles are only invoked in the update phase; When an update is triggerd through <code>`this.setState`</code> or <code>`this.forceUpdate`</code> the <code>`componentWillReceiveProps`</code> lifecycle will not be invoked because new props are not recieved.</p>

		<p>On the other hand if <code>`shouldComponentUpdate`</code> returns <code>false</code> then a component will skip that specific update phase.</p>

<pre><code>
class Welcome {
	componentWillReceiveProps() {}
}
</code></pre>

<pre><code>
class Welcome {
	shouldComponentUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentWillUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidUpdate() {}
}
</code></pre>

		<h2>Umounting</h2>

		<p><code>`componentWillUnmount`</code> is unique in that it is the only lifecycle method that cannot update state because at this phase the component is due to be removed from the DOM.</p>

<pre><code>
class Welcome {
	componentWillUnmount() {}
}
</code></pre>

		<h1>setState</h1>

		<p>A component can update its state by invoking <code>`this.setState`</code> with an Object representing how to update the state or a <code>`Promise`</code> that resolves to a similar Object.</p>

		<p>In addition you could optionaly update the state by returning an Object/Promise from a lifcycle method or event handler; </p>

		<p>For example:</p>

		<h2>Data</h2>

<pre><code>
class Welcome {
	getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Lifecycle</h2>

<pre><code>
class Welcome {
	componentDidMount() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Event</h2>

<pre><code>
class Welcome {
	handleClick() {
		return {n: 0}
	}
	render() {
		h('button', {
			onclick: this.handleClick
		}, 'Click Me')
	}
}
</code></pre>

		<h2>Async</h2>

<pre><code>
class Welcome {
	async getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h1>Render</h1>

		<p>
		For the most part <code>`dio.render`</code> will be how you first invoke DIO. The first argument is the element you want to render and the second the root you want to mount <label for=5></label> to.
		<span class="note">Defaulting to <code>&lt;body></code> or <code>&lt;html></code> if not provided.</span>
		</p>

<pre><code>
dio.render('Hello World')
</code></pre>

<pre><code>
dio.render('Hello World', document.body)
</code></pre>

		<h2>Shallow</h2>

		<p><code>`dio.shallow`</code> on the other hand does not render to the DOM but returns a shallow copy of the passed element. This can mostly be used for testing purposes.</p>

<pre><code>
dio.shallow('Hello World')
</code></pre>

		<h1>Version</h1>

<pre><code>
console.log(dio.version)
</code></pre>

		<h1>Other</h1>

		<h2>Static PropTypes/defaultProps</h2>

		<p>The following would resemble attaching the returned object of the functions to the <code>`Welcome` class</code>.</p>

<pre><code>
class Welcome {
	static propTypes () {
		return {
			id: PropTypes.func.isRequired
		}
	}
	static defaultProps () {
		return {id: 1}
	}
	render () {

	}
}
</code></pre>

		<h2>Error Boundary</h2>

		<p>All components are error safe; This means that if any error where to throw at any point in the components lifecycle DIO would catch it and pass it the <code>`componentDidThrow`</code> method if it exists which can in turn show an error view or try to manually recover from the error state.</p>
<pre><code>
class Welcome {
	componentDidThrow({location, message}) {
		if (location === 'render')
			return h('h1', 'Error State')
	}
	render () {
		throw ''
	}
}
</code></pre>

		<p>Pseudo Code:</p>

		<ol>
			<li>We create a components that intentionally throws in the render phase.</li>
			<li>DIO catches this and passes it to the <code>`componentDidThrow`</code> method if it exists.</li>
			<li>Our <code>`componentDidThrow`</code> method detects if the error comes from <code>`render`</code> and responds with an error state.</li>
		</ol>

		<p>On the other hand if the error happend in the update phase and we did not try to handle it DIO will simply resolve to the last rendered state.</p>

		<h2>Non-Deterministic</h2>

		<p>
			By default rendering something is a deterministic <label for=6></label><span class=note><a href=https://en.wikipedia.org/wiki/Deterministic_system>Deterministic systems.</a></span> operation,
			given the following children <code>`[A, B, C, D]`</code> the path the flow would take would be.
		</p>

		<p class=math>A &#x2192; B &#x2192; C &#x2192; D</p>

		<p>
			But non-deterministic <label for=7></label>
			<span class=note><a href=https://en.wikipedia.org/wiki/Nondeterministic_algorithm>Non-deterministic systems.</a></span>
			introduces the aspect of non-linear updates, where instead of <code>`A &#x2192; B &#x2192; C &#x2192; D`</code> you could get an array of different update sequences; For example:
		</p>

		<p class=math>C &#x2192; D &#x2192; A &#x2192; B</p>

		<p>This is possible because DIO can pause and resume an update to a specific component depending on how long we tell it to wait before following through.</p>

		<p>In the example that follows we wait for a random time before resolving the return value of a render.</p>

<pre><code>
class Welcome {
	render() {
		return new Promise((resolve) => {
			setTimeout(() => {
				resolve(
					h('h1',
						'performance now - ',
						performance.now()
					)
				)
			}, Math.random()*1000)
		})
	}
}
</code></pre>

		<p>If you where to put multiple instances of this component in a list, everytime we call to update the list it should update in a random order between updates.</p>

		<h2>Coroutine</h2>

		<p>In other words Javascript <code>`generators`</code><label for=8></label><span class="note"><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators>Iterators and generators</a></span>; The example that follows will continue to return a button and increment the <code>`supply`</code> variable whenever an update is invoked through a <code>`click`</code> of the button element.</p>

		<p>Though generators are not a well known/used feature in Javascript they do introduce interesting ways to model behaviour beyond normal functons.</p>

<pre><code>
class Coroutine {
	*render(props, state) {
		let supply = 0

		while (true) {
			yield h('button', {
				onclick: this.forceUpdate
			}, 'Click Me - ', supply++)
		}
	}
}
</code></pre>
</code></pre>
	</article>
	<script src=highlight.js></script>
	<script>highlight();</script>
</body>
</html>
