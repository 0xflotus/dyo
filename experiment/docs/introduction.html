<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>DIO</title>
	<link rel=stylesheet href=css/stylesheet.css>
	<link rel="icon" type="image/png" href="imgs/favicon-large.png" sizes="32x32">
	<link rel="icon" type="image/png" href="imgs/favicon-small.png" sizes="16x16">
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=imgs/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/thysultan/dio.js>Github</a>
		</nav>
	</header>
	<article>
		<h1 id=getting-started>Getting Started</h1>

		<p>
			The easiest way to get started with DIO is to use this <a href="#">Hello World Example</a> and follow along through the code snippets. The smallest example looks like:
		</p>

<pre><code>
dio.render(
  h('h1', 'Hello, world!'),
  document.getElementById('root')
)</code>
</pre>

		<p>It renders a heading saying "Hello World" on the page.</p>

		<p>The next few sections will gradually introduce you to the building blocks of an application; Elements and Components. Once you master them, you can create complex applications from small reusable parts.</p>

		<h1 id=installation>Installation</h1>

		<p>DIO can be installed through any one of the following CDN's.</p>

		<ol>
			<li><a href="https://cdnjs.cloudflare.com/ajax/libs/dio/7.0.0/dio.min.js">cdnjs.cloudflare.com/ajax/libs/dio/7.0.0/dio.min.js</a></li>
			<li><a href="https://cdn.jsdelivr.net/dio/7.0.0/dio.min.js">cdn.jsdelivr.net/dio/7.0.0/dio.min.js</a></li>
			<li><a href="https://unpkg.com/dio.js@7.0.0/dio.min.js">unpkg.com/dio.js@7.0.0/dio.min.js</a></li>
		</ol>

		<p>OR through NPM &mdash;</p>
<pre><code>
`npm install dio.js --save`
</code></pre>

		<h1 id=elements>Introducing Elements</h1>

		<p>Elements are the smallest building blocks of an application.</p>
		<p>An element describes what you want to see on the screen:</p>
<pre><code>
const element = h('h1', 'Hello World');
</code></pre>
		<p>
			Virtual elements are plain objects, that are cheap to create and cheap to access. The underlining reconciler takes care of updating the DOM to match the virtual elements you create.
		</p>
		<p>
			Elements are composed of three parts; type <label for="1"></label>,
			<span class=note>
				type represents the type of element that should be rendered.
			</span>
			props <label for="2"></label> and
			<span class=note>
				props represents the attributes associated with an element.
			</span>
			children <label for="3"></label>.
			Each part describes a specific aspect of the element.
			<span class=note>
				children represents the children contained within the element.
			</span>
		</p>
<pre><code>
const element = h('h1', {
	class: 'red'
}, 'Hello World')
</code></pre>

		<h1 id=components>Components</h1>

		<p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p>

		<p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called "props") and return virtual elements describing what should appear on the screen.</p>

		<h2>Functions and Classes</h2>

		<p>The simplest component is a JavaScript function that accepts a single("props") argument.</p>
<pre><code>
function Welcome (props) {
	return h('h1', 'Hello', props.name)
}
</code></pre>
		<p>The second varient <label for=4></label>
		<span class=note>
			There is a third varient called coroutines resembling functions; More details on it in the <a href="api.html#coroutine">API</a> documentation.
		</span>
		 of a component is an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a> that defines your component.</p>

<pre><code>
class Welcome {
	render() {
		return h('h1', 'Hello', this.props.name)
	}
}
</code></pre>
		<p>Function and ES6 class components are equivalent <label for="5"></label>,
		<span class=note>
			This includes support for lifecycle methods on both <code>function</code> and <code>class</code> based components.
		</span>
		 with the exception that class components can contain state.</p>

		<h2>Rendering a Component</h2>

<pre><code>
function Welcome(props) {
  return h('h1', props.name)
}

const element = h(Welcome, {name: 'World'})

dio.render(
  element,
  document.getElementById('root')
)
</code></pre>

		<p>Pseudo Code:</p>

		<ol>
			<li>We create a function component <code>`Welcome`</code> that accepts props and returns <code>&lt;h1>${props.name}&lt;/h1></code></li>
			<li>DIO calls our <code>`Welcome`</code> component with props <code>{name: 'World'}</code>.</li>
			<li>Our <code>`Welcome`</code> component returns an H1 element <br><code>&lt;h1>Hello, World&lt;/h1></code> as the result.</li>
			<li>The reconciler efficiently updates the DOM to match <br><code>&lt;h1>Hello, World&lt;/h1></code>.</li>
		</ol>

		<h1 id=lifecycles>Lifecycle</h1>

		<p>With the introduction of components we can now keep a closer trail of what actions our components are invoking over time, We will call these trails lifecycle methods.</p>

		<h2>Function Example</h2>

<pre><code>
function Welcome () {
	return h('h1', props.name)
}
Welcome.componentDidMount = () => {
	console.log('didMount')
}
</code></pre>

		<h2>Class Example</h2>

<pre><code>
class Welcome {
	componentDidMount() {
		console.log('didMount')
	}
	render() {
		return h('h1', props.name)
	}
}
</code></pre>

		<p>The following table gives us a view into what these methods are called and when they are invoked.</p>

		<hr>

		<table>
			<thead>
				<tr>
					<th>Lifecycle method</th>
					<th>When it gets called</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><code>getInitialState</code></td>
					<td>before instantiating a class component</td>
				</tr>
				<tr>
					<td><code>componentWillMount</code></td>
					<td>before mounting</td>
				</tr>
				<tr>
					<td><code>componentDidMount</code></td>
					<td>after mounting</td>
				</tr>
				<tr>
					<td><code>componentWillUnmount</code></td>
					<td>prior to being removed</td>
				</tr>
				<tr>
					<td><code>componentWillReceiveProps</code></td>
					<td>before new props are received</td>
				</tr>
				<tr>
					<td><code>shouldComponentUpdate</code></td>
					<td>before the component is invoked</td>
				</tr>
				<tr>
					<td><code>componentWillUpdate</code></td>
					<td>after <code>shouldComponentUpdate</code></td>
				</tr>
				<tr>
					<td><code>componentDidUpdate</code></td>
					<td>after the component is invoked</td>
				</tr>
			</tbody>
		</table>

		<h1>Events &amp; State</h1>

		<p>Now that we know how to construct the building blocks of a view, we can start to define our views as a function of their state.</p>

		<p class=math>V=f(s)</p>

		<p>We can then make use of events to respond to user behaviour.</p>

<pre><code>
class Input {
	handleInput(event) {
		const {target} = event
		const {value} = target
		return {value}
	}
	render() {
		return [
			h('input', {
				type: 'text',
				oninput: this.handleInput
			}),
			h('h1', this.state.value)
		]
	}
}

dio.render(h(Input), document.getElementById('root'))
</code></pre>

		<p>Pseudo Code:</p>

		<ol>
			<li>We create an <code>`Input`</code> component that returns a input field and H1 heading.</li>
			<li>We assign <code>`handleInput`</code> to respond to the <code>oninput</code> event.</li>
			<li>DIO calls the <code>`Input`</code> component with no props.</li>
			<li>Our <code>`Input`</code> component returns two elements <br> <code>`&lt;input>&lt;h1>&lt;/h1>`</code> as a result.</li>
			<li>DIO creates the Nodes and attaches the <code>oninput</code> event to <code>`&lt;input>`</code>.</li>
			<li>User types something into our <code>`Input`</code> components <br><code>&lt;input></code> element.</li>
			<li>Our <code>`Input`</code> component retrieves the user input and updates its state.</li>
			<li>The reconciler efficiently updates the DOM to match the new state <code>&lt;input>&lt;h1>${value}&lt;/h1></code>.</li>
		</ol>

		<h1>Moving Foward</h1>

		<p>There's still a few pieces we haven't gone into that the <a href=api.html>API</a> documentation will shed more light upon.</p>

		<p>At this point you can jump right into creating something with DIO, look at some <a href=examples.html>Examples</a> or learn how DIO works under the craft of code on <a href=https://github.com/thysultan/dio.js>Github</a>.</p>

		<p>If you've made anything with DIO i'd be happy to add it to the small list of examples currently available.</p>
	</article>

	<script src=js/highlight.js></script>
	<script src=js/main.js></script>
</body>
</html>
