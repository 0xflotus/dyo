# DIO

[![dio.js](https://cdn.rawgit.com/thysultan/dio.js/master/docs/layout/assets/logo.svg)](http://thysultan.com/dio)

dio is a fast ~8kb framework

- ~8kb minified+gzipped
- ~20kb minified

[![CDNJS](https://img.shields.io/cdnjs/v/dio.svg?style=flat)](https://cdnjs.com/libraries/dio)
[![npm](https://img.shields.io/npm/v/dio.js.svg?style=flat)](https://www.npmjs.com/package/dio.js) [![licence](https://img.shields.io/badge/licence-MIT-blue.svg?style=flat)](https://github.com/thysultan/dio.js/blob/master/LICENSE.md) [![Build Status](https://semaphoreci.com/api/v1/thysultan/dio-js/branches/master/shields_badge.svg)](https://semaphoreci.com/thysultan/dio-js)
 ![dependencies](https://img.shields.io/badge/dependencies-none-green.svg?style=flat) [![Join the chat at https://gitter.im/thysultan/dio.js](https://img.shields.io/badge/chat-gitter-green.svg?style=flat)](https://gitter.im/thysultan/dio.js)

## Support

* Edge
* IE 9+
* Chrome
* Firefox
* Safari
* Node.JS

---


## Installation

#### direct download

```html
<script src=dio.min.js></script>
```

#### cdn

```html
<script src=https://cdnjs.cloudflare.com/ajax/libs/dio/4.0.0/dio.min.js></script>
```

```html
<script src=https://cdn.jsdelivr.net/dio/4.0.0/dio.min.js></script>
```

```html
<script src=https://unpkg.com/dio.js@4.0.0/dio.min.js></script>
```

#### bower

```
bower install dio.js
```

#### npm

```
npm install dio.js --save
```

or play with **dio** [on jsbin](http://jsbin.com/lobavo/edit?js,output)

---

## Getting Started

This getting started guide aims to show you how to go from zero to hello world in **dio**.

```javascript
function Hello () {
	return {
		render () {
			return h('h1' 'Hello ' + this.props.name);
		}
	}
}

dio.render(Hello)({name: 'World'});
```

will mount a h1 element to the page the content of which will be 'Hello World'.

## API

### Components

You can create a component in the following 3 ways.

```javascript
class Hello extends dio.Component {
	render () {
		
	}
}

function Hello () {
	return {
		render () {
		
		}
	}
}

var Hello = () => ({
	render () {
	
	}
});

var Hello = dio.createClass({
	render () {

	}
});
```

#### render 

The render method tells dio what the component will render. This method recieves `props`, `state` & `context` as its arguments and can return a VNode `h(...)` or an array of VNodes `[h()...]`. This is the only required method to render a component.

```javascript
class Hello extends dio.Component {
	render () {
		return h('div', 'Text') || [h('div'), h('div')]
	}
}
```

#### stylesheet

The stylesheet method tells dio how the component appearance will look like(its style/css). This method receieves no arguments but returns a string of css. This css will get namespaced to the component and prefixed where required.

```javascript
class Hello extends dio.Component {
	stylesheet () {
		return `
			color: red;
			
			> h1 { font-size: 20px; }
		`
	}
}
```

#### componentWillUpdate

componentWillUpdate is a method called before the component updates.

```javascript
class Hello extends dio.Component {
	componentWillUpdate () {
		// do something before an update
	}
}
```

#### componentDidUpdate

similar to componentWillUpdate, componentDidUpdate is called after the component updates.

```javascript
class Hello extends dio.Component {
	componentDidUpdate () {
		// do something after an update
	}
}
```

#### componentWillMount

componentWillMount is a method called before the component is mounted to the document.

```javascript
class Hello extends dio.Component {
	componentWillMount () {
		// do something before mounting
	}
}
```

#### componentDidMount

similar to componentWillMount, componentDidMount is called after the component is mounted to the document.

```javascript
class Hello extends dio.Component {
	componentDidMount () {
		// do something after mounting
	}
}
```

#### componentWillUnmount

similar to componentWillMount, componentWillUnmount is called before the component is un-mounted from the document.

```javascript
class Hello extends dio.Component {
	componentWillUnmount () {
		// do something before un-mounting
	}
}
```

#### componentWillReceiveProps

componentWillRecieveProps is called before the component recieves new props.

```javascript
class Hello extends dio.Component {
	componentWillUnmount () {
		// do something before new props are recieved
	}
}
```

#### shouldComponentUpdate

shouldComponentUpdate is a method that is called before the component is rendered and determines if the component should update.

```javascript
class Hello extends dio.Component {
	shouldComponentUpdate () {
		// determine if the component should update
		return false;
	}
}
```

#### setState

setState is a method you can call when the component requires a state update. After updating the state this method will call forceUpdate.

```javascript
class Hello extends dio.Component {
	handleClick () {
		this.setState({id: 1})
	}
	render () {
		return h('div', {onClick: this.handleClick})
	}
}
```

#### forceUpdate

forceUpdate is a method you can call when the component requires a render update.

```javascript
class Hello extends dio.Component {
	handleClick () {
		this.forceUpdate();
	}
	render () {
		return h('div', {onClick: this.handleClick})
	}
}
```

#### bindState

bindState is a method used to bind a property of the components state to a value in the document.

```javascript
class Hello extends dio.Component {
	state: {
		input: ''
	},
	render () {
		return h('input', {onInput: this.bindState('input', 'value')})
	}
}
```

#### getDefaultProps

getDefaultProps is a method used to assign the default props of a component when the component does not received props. This method receives no arguments but returns `undefined|null|Object`.

#### getInitialState

similar to getDefaultProps, getInitialState is a method used to assign the default state of the component. This method receives no arguments but returns `undefined|null|Object`.

#### state

describes the current state of the component, you can declare the initial state of a component in 3 ways using any of the conventions of creating a component.

```javascript
class Hello extends dio.Component {
	getInitialState () {
		return {id: 1234}
	}
}

function Hello {
	return {
		state: {id: 1234}
	}
}

function Hello {
	return {
		constructor () {
			this.state = {id: 1234}
		}
	}
}
```

#### props

props are the values passed down to a component, the convention is that they should be treated as immutable objects, that is you shouldn't do `this.props.value = 1` though nothing will break if you do and nothing stops you from doing that.

## Elements

Elements are of three types, `VComponent`, `VElement`, `VText` and `VSvg`, the `h` and `createElement` functions hide away these low-level types that you can access if the need arises. In a browser enviroment `h` is exposed to the global scope.

```javascript

class Hello extends Component {
	render () {
		return h('div');
	}
}

// VComponent passing {id: 1} as props to the component
// and textNodes 1 and 2 as children
var component = h(Hello, {id: 1}, 1, 2)

// VElement passing textNodes 'Hello' and 'World' as children
var element = h('div', 'Hello', 'World')

// VSvg passing a path svg element as a child
var h('svg', h('path'))

// VElement passing props 
// {type: 'checkbox', checkbox: true, className: 'green'}
var special = h('input.green[type=checkbox][checked]')

// VElement passing a VComponent as a child
var element = h('div', Hello);
```


## createFactory

createFactory creates a new element constructor/factory. This method receives two arguments to second of which is an optional props and the first the type of the element.

```javascript
var h1 = dio.createFactory('h1', {class: 'headings'});

var welcome = h1('Welcome');
var goodby = h1('GoodBye');
```

## DOM

DOM is similar to createFactory except it receieves one array of strings arguments that is used to create multiple factories.

```javascript
var {h1, p, div} = dio.DOM(['h1', 'p', 'div']);

var heading = h1({class: 'heading'}, 'Heading');
```

## isValidElement

isValidElement runs a check on the passed argument if the value is an virtual element.

```javascript
dio.isValidElement(h('h1'));
```

## cloneElement

cloneElement accpets 3 arguments, `(element, newProps, newChildren)` the last two of which are optional, when newProps are passed it shallow clones newProps and replaces the elements children with newChildren if passed as an argument. 


## render

Not to be confused with the Component method render `dio.render` i used to mount a Component/Element to the document and create render factories. As you will recall in the getting started section we did something like this.

```javascript
function Hello () {
	return {
		render () {
			return h('h1' 'Hello ' + this.props.name);
		}
	}
}

dio.render(Hello)({name: 'World'});
```

The render method however also accepts a second argument, a mount element/mount selector defaulting to `document.body` if omitted.

```javascript
dio.render(Hello)({name: 'World'}, '.container');
```

this method returns a render instance that can be used to re-render as needed.

```javascript
var hello = dio.render(Hello)({name: 'World'}, '.container');
hello({'Mars'});
```

Will update the documents `<h1>Hello World</h1>` to `<h1>Hello Mars</h1>`

## renderToString

similar to render but renders the output to a string. This is usefull in a server-side enviroment.

```javascript
function Hello () {
	return {
		render () {
			return h('h1' 'Hello ' + this.props.name);
		}
	}
}

dio.renderToString(Hello, template)
``` 

This method accepts to arugments the second of which is an optional `template` string/function that is used to determine where to render the output. for example you could use it in the following ways

```javascript
// default
var output = dio.renderToString(Hello)

// template string, 
// where @body is replaceing with the output
var output = dio.renderToString(Hello, `
	<html>
		<title>Hello</title>
		<body>@body</body>
	</html>
`);

// where @stylesheet is a string of all the css generated from
// the Hello Component including children
var output = dio.renderToString(Hello, function (body, stylesheet) {
	return `
		<html>
			<title>Hello</title>
			
			@stylesheet
			
			<body>@body</body>
		</html>
	`
})
```

## renderToStream

similar to renderToString except this method renders the output to a stream. This is usefull in a server-side enviroment as well and has the advantage over renderToString in that it is non-blocking and delivers chunks of bytes to the client for great "time to first bytes" and overall constant CPU load.

```
dio.renderToStream(Hello, template)
``` 

This method like renderToString accepts 2 arguments the second of which is differs from renderToString in that it expects `template` to be a string if passed.


## createStore

```javascript
dio.createStore(
	// single or multiple reducers
	// if an object of reducers, combineReducers is called to combine them
	reducer: {(function|Object)}, 
	// initialState/middleware
	initalState: {Any}          
	// middleware, applyMiddleware is called 
	// on the enhancer function internally if passed
	enhancer: {Function}        
)
```

This method creates a store similar to redux createStore
with the different of `.connect` that accepts a component & mount/callback
with which to update everytime the store is updated.

Which is short hand for creating a listerner with `.subscribe`
that updates your component on state changes.

```javascript
var store = dio.createStore(reducer: {Function})
// or

// auto .combineReducers
var store = dio.createStore(object of reducers: {Object})

// dispatch an action
store.dispatch({type: '' ...})

// returns the current state
store.getState()

// called everytime the state is updated with the current
// state as the only argument passed to it... as in
// function (state) {  }
store.subscribe(listener: {Function})

// if the callback is a component, a render will get auto created
// if element is passed the callback will be treated as a component
// and it follows that a render will get auto created
store.connect(callback: {function})
store.connect(callback: {(function|Object)}, element: {(string|Node)})
```

## applyMiddleware

although you can archive the same effect with the third argument of `createStore()` applyMiddleware is exposed as a public api to allow manual handling of the above proxy detailed in createStore. applyMiddleware accepts a variable number of function arguments that are composed into middlewares.

```javascript
dio. applyMiddleware(fn, fn, fn...);
```

## combineReducers

This method allows you manually handle combinding multiple reducers into one. It accepts one `{Object<string, function>}` argument.

```javascript
var reducer = dio.combindReducers({
	add: () => {},
	subtract: () => {}
})
```


## request

request is a method that provides a http layer to help make ajax calls to api end points. For example if i wanted to make a get request to `google.com` i could do it in one of the following ways

```javascript
dio.request('google.com');
dio.request.get('google.com');
dio.request({url: 'google.com'})
```
Below is a full run down of all the arguments the request method accepts, all of which are optional with the exception of the `url`.

```javascript
// returns a stream
dio.request(
	url:             {string}, 
	payload?:        {Object},

	// 'file' | 'json' | 'text',
	// default: 'application/x-www-form-urlencoded'
	enctype:         {string=}, 
	
	// defaults to determine responseType based on response
	responseType:    {string='(html|document)'|'json'|'text'}

	// true/false
	// indicates whether CORS requests should be made 
	// using credentials such as cookies, 
	// authorization headers or TLS client certificates.
	withCredentials: {boolean=},

	// initial value of the returned stream 
	// before the request completes
	initial:         {any=},

	// request headers to assign 
	headers:          {Object=},

	// exposes xhr object for low level access 
	// before the request is sent
	config:          {function=},

	// username & password for HTTP authorization
	username:        {string=}, 
	password:        {string=}
)
```
examples creating `POST` and `GET` requests. 

```javascript
// options as arguments
dio.request.post('/url', {id: 1234}, 'json')
	.then((res)=>{return res})
	.then((res)=>{'do something'})
	.catch((err)=>{throw err});

// options as object
dio.request({
	method: 'GET',
	url: '/url',
	payload: {id: 1234},
	enctype: 'json',
	withCredentials: false,
	config: function (xhr) {
		xhr.setRequestHeader('x-auth-token',"xxxx");
	}
}).then((res)=>{return res})
  .catch((err)=>{throw err});
```

## router

This methods accepts three or two arguments and returns a router. In the below example `/user/dio` is the initial route to navigate to and `/catagory` represents the root address of the app, both of which are optional arguments.

```javascript
var router = dio.router({
	'/': function (data) {
		dio.render(h(home, data))
	},
	'/user/:id': function (data) {
		dio.render(H(user, data));
	}
}, '/catagory', '/user/dio')
```

Alternatively you can also create a router using a mount element and Components.

```
var router = dio.router({
	'/': Bar,
	'/user/:id': Foo
}, {
	mount: document.body
});
```

In both cases `:id` variables are passed to Foo and Bar as props when the route is activated or to the function specified such that in the case where the url `/user/1234` is matched the object passed will be represented as `{id: 1234}`. You can the use the router to navigate as needed with `router.nav` or link it to an action with `router.link`

```javascript
// navigate to
router.nav('/user/sultan')

// history back
router.back()

// histroy forward
router.forward()

// creates a callback attached to the href attribute
router.link('href')
```
for example

```javascript
h('h1', {onClick: router.link('href'), href: '/'}, 'Home')

// or an explicit url
h('h1', {onClick: router.link('/')}, 'Home')

// or a function
h('h1', {onClick: router.link(el => { 
	return el.getAttribute('href')
}), href: '/'}, 'Home') 
```


## stream

streams in dio are convinient getters/setters that also act like promises. For example `var foo = dio.stream(10)`. The variable foo now holds a function that when called without any arguments returns 10 `foo()` and updates the value that foo holds when called with an argument `foo(20)`.

The second argument in `dio.stream` is a optional argument representing a mapper, this allows use to extend streams in different ways.

Before we go into extending stream it's important to know that like promises streams have `.then`, `.done` and `.catch` methods that can be used to listen for the resolution and/or rejection of a stream.

```javascript
var foo = dio.stream(10).then(foo => console.log(foo))
foo(20); // => 20

// or
var foo = dio.stream(function (resolve, reject) {
	setTimeout(resolve, 0, 20);
}).then(foo => console.log(foo)).catch(msg => console.log(msg))
```

Which allows the above piece of code to log the value of foo everytime the value successfully resolves and log the error message anytime it rejects.

If you wanted to insure that the value returned by the stream is always of a certain type you can use a the mapper interface to run the resolved value though before receiving it.

```javascript
var string = dio.stream(100, String);
string()     // => '100'
string(1)(2) // => '2'
```

streams also have a `.map` method which allows you to create a stream that is dependent on another streams value such that when the value of one stream changes so does the other.

```javascript
var foo = dio.stream(10);
var bar = foo.map(function (foo) {
	return foo * 2;
});

bar()  // => 20
foo(2)
bar()  // => 4 
```
Since streams a similar to promises creating a stream in a resolved/rejected state applies to streams as well though creating streams in a resolved state is identical to creating streams, for example the following to are the same.

```javascript
var foo = dio.stream.resolve(10);
var foo = dio.stream(10);
```
the following is a stream created in a rejected state

```javascript
var foo = dio.stream.reject('reason');
```

The above stream api allow use to extend streams as needed. To showcase this i will try to extend the streams with a `.scan` method that creates streams that accumulates everytime it is called such that calling `foo(1)(1)(2)` will result in a stream `bar` holding the value `4`

```javascript
dio.stream.scan = function (reducer, accumulator, stream) {
	return Stream(function (resolve) {
		stream.then(function () {
			accumulator = reducer(accumulator, stream);
			resolve(accumulator);
		});
	});
};

// @example 
var foo = dio.stream();
var bar = dio.stream.scan((sum, n) => { 
	sum + n
}, 0, foo);

foo(1)(1)(2)
bar() // => 4 
```

## Utilities

### defer

defers the execution of a function with a set number of arguments and an option option to disable default event actions with preventDefault

```javascript
h('form', {onSubmit: dio.defer(func, [1,2], true)})
```

### panic

creates a panic/error state with the passed message, with an optional second argument to determine if the panic is silent or otherwise.

```javascript
dio.panic('message')
```

### sandbox

accepts 3 arguments the last 2 of which are optional `dio.sandbox(func, onError, value)` sandboxes the executing of a function `func` in a `try catch block` with the `value` if a value is passed and calling `onError` with the stack trace if an error surfaces.

### random

generates a random string of letters given a length. `dio.random(5)`


### escape

efficently escapes an untrusted string `dio.escape(inputValue)`

### compose

creates a composition of multiple functions `dio.compose(fn, fn...)`
